; язык Clojure имеет не так много основных структур данных, но
; это является частью философии языка
; подразумевается максимальное использование имеющихся инструментов


; -- -- keywords -- --
; широко используются как ключи в map,
; так же как функции, которые ищут соответствующие ключи в map
; (в том числе другие применения кроме ^)
(def m {:a 0 :b 1 :c 2})
(:a m) ; <=> (get m :a) ; 0


; -- -- maps -- --
; maps похожи на словари или хэши в других языках
; (ассоциация одного значения с другим)
; в Clojure сущестует 2 типа maps: hash maps и sorted maps

; литерал
{:first-name "Charlie"
 :last-name "McFishwich"}

; создание через функцию
(hash-map :a 1 :b 2)
; => {:a 1 :b 2}

; поиск через keyword
(def m {:a 0 :b 1 :c 2})
(:a m) ; <=> (get m :a) ; 0

; поиск через get
; ищем значение, ассоциирующиеся с ключем :b
(get {:a 0 :b 1} :b) ; 1
(get {:a 0 :b {:c "ho hum"}} :b) ; {:c "ho hum"}

; nil - если ничего не найдено
(get {:a 0 :b 1} :c) ; nil

; поиск вложенных map
(def m {:a 0 :b {:c "hey"}})
(get-in m [:b :c]) ; hey


; -- -- sets -- --
; sets - это коллекции уникальных значений
; бывают hash sets и sorted sets

#{1 "ab" :a}

; можно создавать явно используя hash-set
(hash-set 1 1 2 2); #{1 2}

; при слиянии, повторяющиеся элементы будут отбрасываться
(conj #{:a :b} :b) ; #{:a :b}

; можно создавать set из существующих vector и list
(set [3 3 4 5 2 2]) ; #{3 4 5 2}
(set '(1 1 2 2 3)) ; #{1 3 2}

; проверка наличия какого-либо элемента
(contains? #{:a :b} :a) ; true
(:a #{:a :b}) ; :a
(get #{:a :b} :k) ; nil

; примеры использования set (и into)
(into [:a :b] (set [:c :c :d])) ; [:a :b :c :d]


; -- -- vectors -- --
; похожи на массивы в других языках
; элементами могут являться любые типы данных
; удобно добавлять новые и удалять старые значения

; можно создать как через литерал
(def v [1 2 3])
; так и через функцию
(def v (vector "a" "b" "c"))

; много удобных методов для работы
(vector? [5 10 15]) ; true
(first [5 10 15]) ; 5
(rest [5 10 15]) ; (10 15)
(nth [5 10 15] 1) ; 10
(count [5 10 15]) ; 3
(conj [5 10] 15) ; [5 10 15] (важно, что эл-ты добавляются в конец)

; поиск по индексу через get
(get [3 2 1] 0) ; 3
(get ["a" 123 false {:a "Hey"}] 3) ; {:a "Hey"}

; то же самое будет работать и без get
([3 2 1] 0) ; 3
(["a" 123 false {:a "Hey"}] 3) ; {:a "Hey"}


; -- -- lists -- --
; похожи на vector
; TODO: узнать больше о разнице между list и vector

; нельзя получить элемент через get, только через nth
; стоит отметить, что nth операции поиска медленнее чем get
(def l '(1 2 3 4))
(nth l 0) ; 1

; так же элементы добавляются в начало списка
(conj '(1 2 3) 4) ; (4 1 2 3)
