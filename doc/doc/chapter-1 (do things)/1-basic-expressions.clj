; --- --- --- АРИФМЕТИЧЕСКИЕ ОПЕРАТОРЫ --- --- ---
; -----------------------------------------------------

; -- -- цепочка сравнения -- --
(< 1 a 2) ; 1 < a && a < 2

; -- -- комплексные операции -- --
; -1 + 2*x - (a - b)*(x - y)
(-
  (+ -1 (* 2 x))
  (* (- a b)(- x y)))



; --- --- --- УСЛОВИЯ --- --- ---
; ---------------------------------

; -- -- or & and -- --

; or - вернет либо первое правдивое либо последнее значение
; and - первое ложное значение, иначе - последнее правдивое

(or false nil :large_I_mean_venti :why_cant_I_just_say_large)
; => :large_I_mean_venti

(and :free_wifi :hot_coffee)
; => :hot_coffee


; -- if -- --
(if <test> <then> <else>)

(if (< 1 2)
  "1 < 2"
  "1 > 2")

; falsey (только эти 2 значения)
false nil

; truthy (все, кроме false)
true 123 "abc" "" [1 2 3] [] 0 ; и тд.



; --- --- --- ВЫРАЖЕНИЯ --- --- ---
; ------------------------------------

; -- -- do -- --
; выполняет заданные инструкции и возвращает значение последней
(do
  1
  (println("hey"))
  3) ; 3

; do часто пригождается, когда в ветке if нужно сделать несколько действий
(if true
  (do
    (println "Success!")
    (+ 1 2 3)
    "By Zeus's hammer!")
  (do
    (println "Failure!")
    (- 1 2 3)
    "By Aquaman's trident!"))


; -- -- when -- --
(when <test> <then>) ; т.е без else
; если условие ^ ложно, вернется nil
(when (< 1 2)
  "1 < 2")


; -- -- let -- --
; создание пар - символьное имя + значения
; т.е можно сделать несколько присвоений, а затем в теле let на них ссылаться

; let позволяет выполнить вырожение, а затем связать результат
; этого выполнения с символом, чтобы затем использовать повторно*

; созданные значения (пары) буду доступны только в теле let
; по мере присвоения, можно ссылаться на ранее созданные значения (пары)
(let [a 1
      b (* a 2) ; * - выполняем выражение и связыываем его с символом b
      c 3]
  (+ a b c))

; rest
(let [[first & rest] ["Awesome" "Hey" "Hello" "Bye"]]
  [first rest]) ; ["Awesome" ("Hey" "Hello" "Bye")]


; -- -- loop & recur -- --
(loop [iteration 0]
  (if (> iteration 3)
    (println "Done")
    (recur (inc iteration))))
