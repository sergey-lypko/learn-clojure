; стандартная запись функции
; в текущем неймспейсе создается символьное имя f,
; куда присваивается сама функция
(defn f [x]
  (inc x))

(f 5) ; вызов по имени


; -- -- арность -- --
; кол-во принимаемых аргументов называется арностью
; существует перегрузка арности: когда в зависимости от кол-ва п-в
; выполняются соответствующие блоки кода
(defn multi-arity
  ([] ...)
  ([one-arg] ...)
  ([one-arg two-arg] ...))


; -- -- n-м кол-вом аргументов -- --
(defn f1 [& args] map args)
(f1 1 2 3) ; (1 2 3)

(defn f [x & rest]
  (println rest)
  x)
(f 1 2 3 4) ; (2 3 4)


; -- -- деструктуризация -- --
(defn f [[first second]] second)
(f [15 20 30]) ; 20

; вместе с rest
(defn f [[first second & rest]] rest)
(f [1 2 3 4 5]) ; (3 4 5 6)

; деструктуризация map аргумента
; локальный биндинг lat с ключем :lat и lng с ключем :lng
(defn f [{lat :lat lng :lng}] lng)
(f {:lat 28.11 :lng 25.12}) ; 25.12

(defn f [{:keys [mine halt]}] halt)
(f10 {:mine 10 :halt 21}) ; 21

(defn f [{:keys [me you] :as we}] we)
(f {:me "me" :you "you"}) ; {:me "me", :you "you"}


; -- анонимная функция --
(fn [x] (inc x))

; анонимная функция может быть присвоена в def
(def f (fn [x] (inc x)))

; короткая запись
; % - это аргумент
; короткая запись подходит, когда можно декларативно применить абстрактную ф-ю
; например *, str, reduce, +, inc и т.д
(#(* % 3) 8) ; 24
(#(str "Hey" % "and bye") "You") ; "Hey You and bye"
(map #(str "Hi, " %) ["You" "Me"]) ; ("Hi, You" "Hi, Me")


; -- -- замыкания -- --
; (необязательно через анонимные функции)
; внутренняя функция имеет доступ к локальным значениям и аргументам
; внутри родительской функции

(defn my-inc [inc-by] #(+ % inc-by))
; биндим параметр inc-by из ^ с символом inc3
(def inc3 (my-inc 3))
; затем вызов самой анонимной функции
(inc3 7) ; т.е здесь 7 - это вот тот процент из #-функции внутри my-inc


; -- -- asserts -- --
; пред и постусловия
; можно изначально задать проверку, для входящего значения и результата
(defn f ^{ :pre [(pos? x)]
           :post [(< % 15)] }
  [x]
  (* x 5))
