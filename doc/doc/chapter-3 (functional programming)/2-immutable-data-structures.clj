; итак, чистые функцие характеризуются отсутствием сайд эфектов
; конечно, невозможно полностью их избежать, но следует максимально ограничить
; в Clojure все структуры данных иммутабельны, а процедуры над ними
; выполняются с помощью чистых функций


; -- -- рекурсия -- --
; вместо циклов
let someResult = 0

for (var i = 0, i < some.length, i++) {
  .. making stuff && someResult = someResult + some[i]
}
; (P.S: структуры данных в Clojure вообще не допускают подобных ^ мутаций)

; используется рекурсия
(defn sum
  ([vals] (sum vals 0))
  ([vals total]
    (if empty? vals)
      total
      ; (rest vals) - tail of the recursion (хвост)
      (sum (rest vals) (+ (first vals) total))))
; каждый рекурсивный вызов создает новую область видимости, где
; vals и total соответствуют разным значениям

; в целях оптимизации, рекурсивные вызовы принято записывать через recur
; это особенно важно, когда обрабатываемые коллекции содержат большое к-во эл-в
; (...)
(recur (rest vals) (+ (first vals) total))))


; -- -- композиция -- --
; рекурсия является частным случаем композиции функций - функция
; получает в качестве аргумента результат выполнения самой себя

; функциональные языки программирования поощряют построения сложных
; вычислений и функций с помощью комбинаций (композиций) более
; простых функций
((comp inc *) 2 3) ; 7

; получение значений в map
(def character
  {:name "Rustem"
   :attributes {:power 10
                :speed 12
                :health 84}})

(def character-speed (comp :speed :attributes))
(def character-health (comp :health :attributes))

(println (character-speed character)) ; 12
(println (character-health character)) ; 84

; аналогичный результат ^ без использования comp
(defn character-speed
  [c] (:speed (:attributes c)))

(println (character-speed character)) ; 12

; если одна из функций в цепочке композиции принимает больше
; одного аргумента, ее можно оберунть в анонимную функцию
((comp int inc #(+ 2.5 %)) 5) ; 8

; композициях двух функций
(defn two-comp
  [f g]
  (fn [& args]
    (f (apply g args))))

(println ((two-comp inc +) 10 12))

; TODO реализовать my-comp наподобие two-comp ^ для
; бесконечно допустимого числа аргументов


; -- memo -- --
; ссылочная прозрачность чистых функций позволяет полагаться на
; результат выполнения таким образом, чтобы функции могли избежать повторных
; вычислений при одних и тех же агрументах
(defn sleepy-greeting
  [name]
  (Thread/sleep 1000)
    (str "Hello, " name))

(def memo-sleepy-greeting (memoize sleepy-greeting))

(println (memo-sleepy-greeting "Mark")) ; after 1 sec
(println (memo-sleepy-greeting "Mark")) ; immediately


; -- иммутабельность: summary -- --
; иммутабельные структуры данных накладывают важные ограничения
; они позволяют избежать, но так же вообще не беспокоиться о потенциальных
; непреднамеренных и нежелательных изменениях различных данных с течением
; жизненного цикла программы, что критически влияет на надежность,
; читабельность и поддерживаемость кода
