; sequence abstraction* - это абстрагирование от конкретных структур данных
; абстрактная последовательность характеризуется по главному признаку:
; структура данных соответствует главным операциям first, rest и cons
; в случае соответствия, над такой СД можно выполнять любые другие
; операции, которые можно выполнить над абстрактной поc-ю,
; в том числе map, reduce и т.д
; это называют абстрактным программированием и такая философия лежит
; в основе языка Clojure

; если над каким-либо объектом (СД) можно выполнить абстрактные операции,
; то такой объект (СД) будет являться экземпляром абстракции
; такой принцип применим не только к программированию:
; напрмер есть некое устройство для зарядки телефонов
; у него есть главные отличительные черты - возможность подключиться к сети и
; возможность подключиться к телефону (и зардить его)
; и здесь уже не так важно, что вообще из себя представляет само устройство -
; то ли это литий-ионный акумулятор или же помидор с воткнутыми проводками
; важно то, что некая сущность будет выполнять свои функции

; похожим образом, map в Clojure не заботит как реализованы lists, vectors,
; sets и др, важно только возможно ли выполнить над этими СД
; операции абстрактной последовательности (first, rest и cons)
; язык подразумевает максимальное абстрагирование от конктретных СД в пользу
; sequence abstraction
; если основные функци first, rest и cons применимы к какой-либо
; структуре данных, то такая СД будет реализовать и абстракию последовательности

; lists, vectors, sets и maps все реализуют такую абстракцию
; и в итоге map применима к таким СД
(defn titlize
  [topic]
  (str topic " for the Brave"))

(map titlize ["Hamsters" "Ragnarok"])
(map titleize '("Hamsters" "Ragnarok"))
(map titleize #{"Hamsters" "Ragnarok"})
; => ("Hamsters for the Brave" "Ragnarok for the Brave")


; -- -- Indirection -- --
; важный вопрос - это то, как в Clojure функции для работы с пос-ми
; (first, map, reduce и т.д) применимы к разным структурам данных
(first [1 2 3]) ; 1
(first '(1 2 3)) ; 1
(first #{1 2 3}) ; 1
(first {:first 1 :second 2}) ; [first 1]

; Indirection - термин, описывающий поведение, при котором имя
; может иметь несколько связанных значений
; в примерах выше ^, first имеет множество специфических для конкретной СД значений
; Indirection - это то, благодаря чему, становится доступна такая абстракция (SA*)

; В Clojure один из способов реализации Indirection - это полиморфизм
; грубо говоря, полиморфные функции в языке выполняют разные body, в зависимости
; от типа передаваемых аргументов (это похоже на принцип арности)

; обрабатывая пос-ти, Clojure выполняет легковесное преобразование,
; создавая СД, которая будет соответствовать методам (SA*) (first, map, reduce и т.д)


; -- -- lazy seq -- --
; пос-ти в Clojure сделаны хитрым образом, при котором эл-ты пос-ти
; не вычисляются до тех пор, пока к ним не появится явного обращения

; такой механизм позволяет создавать infinite seq:
(take 3 (repeat "hey")) ; ("hey" "hey" "hey")

; -- -- рекурсивная модель бесконечной пос-ти:
(defn even-numbers
  ([] (even-numbers 0))
  ([n] (cons n (lazy-seq (even-numbers (+ n 2))))))
; (cons 10 [1 2 3])) => (10 1 2 3)
; фактически even-numbers - это бесконечная пос-ть

(defn fib
   ([] (fib 1 1))
   ([a b] (cons a (lazy-seq (fib b (+ a b))))))

(println (take 10 (fib))) ; (1 1 2 3 5 8 13 21 34 55)

; я бы назвал это потенциальной последовательностью ^
; которая начнет вычисляться после явного обращения к n кол-ву ее эл-ов
(def res (take 10 (even-numbers)))
(println res) ; (0 2 4 6 8 10 12 14 16 18)
